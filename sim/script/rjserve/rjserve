#!/usr/bin/env ruby

# == Synopsis
#
# rjserve: Run a generic job server
#
# == Usage
#
# rjserve [-n threads]
#
# -n number, --num-threads number
#     Number of threads to run processing inserted jobs.  Defualts to 1.

$:.unshift(File.dirname(__FILE__))

require 'rdoc/usage'
require 'drb'
require 'thread'
require 'job_types'

SERVER_ADDR = "localhost:7005"
ENV['PATH'] = ".:" + ENV['PATH']

opts = GetoptLong.new(['--num-threads', '-n', GetoptLong::REQUIRED_ARGUMENT],
		      ['--address',     '-a', GetoptLong::REQUIRED_ARGUMENT])

num_threads = 1
server_addr = SERVER_ADDR
opts.each do | opt, arg |
  case opt
  when '--num-threads'
    num_threads = arg.to_i    
  when '--address'
    server_addr = arg
  else
    RDoc::usage
    exit(0)
  end
end

class RJobServer
  HEAD = :head
  TAIL = :tail

  def initialize
    @queue = []
    @queue_mutex = Mutex.new
    @uid = 0
  end

  def add_job(job, position = TAIL)
    @queue_mutex.synchronize do
      case position
      when HEAD
        @queue.insert(0, [job, @uid])
      when TAIL
        @queue << [job, @uid]
      end
      @uid += 1
    end
  end

  def next
    job = nil
    @queue_mutex.synchronize do
      job = @queue.shift
    end
    return job
  end

  def get_queue
    return @queue.map { | entry | [entry[0].to_s, entry[1]] }
  end

  def clear_queue
    @queue_mutex.synchronize do
      @queue.clear
    end
  end

  def clear_entries(uid)
    if uid.respond_to? :each
      uid.each { | x | clear_entries(x) }
    end

    @queue_mutex.synchronize do
      entry = @queue.find { | e | e[1] == uid }
      if !entry.nil?
        @queue.delete(entry)
      end
    end
  end

end

printf("RJServe running on %s...", server_addr)
server = RJobServer.new
DRb.start_service("druby://#{server_addr}", server)
printf(" done.  Waiting for jobs.\n")

procs = []
while(1)
  if procs.length == num_threads
    procs.delete(Process.wait)
  end
  
  job = nil
  while(job.nil? || !job[0].runnable?)
    sleep 0.1
    job = server.next
  end

  puts "Currently spawning job #{job[1]}"
  procs << fork do
    puts "Running #{job[0]}."
    job[0].run
  end
end

# replace with main loop
DRb.thread.join # Don't exit just yet!
